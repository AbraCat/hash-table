В данной работе исследуются ассемблерные оптимизации хеш-таблицы с закрытой адресацией. Исследуемая хеш-таблица хранит строки. В неё вставляются все слова из "Властилина колец" Толкина, затем измеряется производительность при 1 миллионе операций поиска. Профилирование проводится с помощью Valgrind с использованием расширения Callgrind. Он измеряет количество тактов процессора, потраченное на выполнение каждой функции, а также общее количество тактов. После профилирования фукнции сортируются по убыванию количества тактов, и самые затратные подвергаются оптимизации. В качестве хеш-функции использовалась crc32. В учебных целях load factor хеш-таблицы был увеличен до 20.

Программа прошла несколько стадий оптимизации:
* Неоптимизированная версия, компилировалась без флагов оптимизации. Самой затратной функцией оказалась strcmp
* Копмиляция с флагом O2. Применение оптимизаций компилятором помогло ускорить прогрмму в 1.3 раза. Strcmp сталась на первом месте.
* Оптимизация strcmp. Для оптимизации использовались intrinsic-фукции. Функция _mm_cmpistri позволяет проводить сравнение строк, лежащих в __m128. Использовалась комбинация флагов, при которой эта фнукция возвращает индекс первого бита, в котором строки различаются. Если строки равны, он должен быть 16. Все рассматриваемые слова имеют длину не более 31, поэтому для проверки равенства достаточно двух вызовов функции. Эта оптимизация ускорила программу в 1.3 раза. Код оптимизированной функции:
```
int mystrcmp(const char* lft, const char* rgt)
{
    int ind1 = _mm_cmpistri(_mm_loadu_si128(lft), _mm_loadu_si128(rgt), _SIDD_NEGATIVE_POLARITY | _SIDD_UBYTE_OPS | _SIDD_CMP_EQUAL_EACH | _SIDD_LEAST_SIGNIFICANT);
    int ind2 = _mm_cmpistri(_mm_loadu_si128(lft + 16), _mm_loadu_si128(rgt + 16), _SIDD_NEGATIVE_POLARITY | _SIDD_UBYTE_OPS | _SIDD_CMP_EQUAL_EACH | _SIDD_LEAST_SIGNIFICANT);
    return !(ind1 == 16 && ind2 == 16);
}
```

* Оптимизация хеш-функции. После оптимизации strcmp она остаась самой затратной, поэтому было решено оптимизировать фнукцию на втором месте (хеш-функцию). Оптимизация осуществлялась с помощью ассемблерных вставок. Использовалась иструкция 86-64, вычисляющая crc32 64-битового значения. Чтобы посчитать хеш слова, она применялась 4 раза, при этом хеш предыдущей части строки передавался одним из аргументов. Оптимизация дала ускорение в 1.2 раза. Код оптимизированной функции:
```
int __attribute__ ((noinline)) my_hash_fn(const char* s, int mod)
{
    long long hash, str;
    asm volatile(
        "movq $-1, %0\n"

        "mov (%1), %2\n"
        "crc32 %2, %0\n"
        "add $8, %1\n"

        "mov (%1), %2\n"
        "crc32 %2, %0\n"
        "add $8, %1\n"

        "mov (%1), %2\n"
        "crc32 %2, %0\n"
        "add $8, %1\n"

        "mov (%1), %2\n"
        "crc32 %2, %0\n"

        : "+r" (hash), "+r" (s), "=r" (str)
    );
    
    return (hash % mod + mod) % mod;
}
```

* Оптимизация поиска в списке. После оптимизации хеш-функции на втором месте оказалась фнукция поиска в списке. Она была переписана на ассемблере в отдельном файле, который после компиляции линковался с основной программой. Эта оптимизация на дала никаких улучшений, поэтому было решено её отбросить.

Таблица с результатами измерения производительности всех версий:

| Версия       | Общее кол-во тактов | Коэфф. опт. отн. предыд. | Коэфф. опт. отн. v1 | Коэфф. опn. отн. v2 |
| ------------ | ------------------- | ------------------------ | ------------------- | ------------------- |
| исходная     | 666572817           | -                        | 1.000               | -                   |
| копмил. с O2 | 513293311           | 1.299                    | 1.299               | 1.000               |
| strcmp       | 392672123           | 1.307                    | 1.698               | 1.307               |
| hash-fn      | 329859375           | 1.190                    | 2.021               | 1.556               |
| lst-find     | 320859375           | 1.000                    | 2.021               | 1.556               |

Итоговая версия программы оказалась быстрее исходной, скомпилированной без флагов, в 2 раза, и в 1.5 раза при компиляции с O2.
